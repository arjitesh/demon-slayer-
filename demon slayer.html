<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Demon Slayer: Path of the Sword (3D)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #111827;
        }
        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .screen {
            background-color: rgba(17, 24, 39, 0.9);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 1rem;
            padding: 2rem;
            text-align: center;
            color: white;
            max-width: 90vw;
            width: 500px;
            position: absolute;
            z-index: 10;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }
        .spinner {
            font-size: 2.5rem;
            font-weight: bold;
            color: #38bdf8; /* sky-400 */
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 1.5rem 0;
            border: 2px dashed #374151; /* gray-700 */
            border-radius: 0.5rem;
            background-color: #1f2937; /* gray-800 */
        }
        .btn {
            display: inline-block;
            background-color: #2563eb; /* blue-600 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
            border: 1px solid #1d4ed8;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
        }
        .btn:hover {
            background-color: #1d4ed8; /* blue-700 */
        }
        .btn:disabled {
            background-color: #4b5563; /* gray-600 */
            cursor: not-allowed;
        }
        #combatUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #gameCanvasContainer {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .health-bar-container {
            background-color: rgba(0, 0, 0, 0.25);
            border-radius: 9999px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.5);
            padding: 2px;
        }
        .health-bar {
            height: 16px;
            border-radius: 9999px;
            transition: width 0.5s ease-in-out;
            box-shadow: inset 0 2px 4px 0 rgba(0,0,0,0.2);
        }
        .player-health {
            background: linear-gradient(to right, #4ade80, #22c55e);
        }
        #messageOverlay {
            z-index: 20;
        }
        #chargeBar.full {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(56, 189, 248, 0); }
        }
        #worldSpaceUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .demon-health-bar-world-container {
            position: absolute;
            width: 80px;
            height: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            transform: translate(-50%, -50%);
            padding: 1px;
            display: none;
        }
        .demon-health-bar-world-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #f87171, #ef4444);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
        }
        #joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(0,0,0,0.2);
            border-radius: 50%;
            pointer-events: auto;
        }
        #joystick-thumb {
            position: absolute;
            top: 30px;
            left: 30px;
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.5);
        }
        #action-buttons {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            pointer-events: auto;
        }
        .action-btn {
            width: 60px;
            height: 60px;
            background: rgba(0,0,0,0.4);
            color: white;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            user-select: none;
        }
    </style>
</head>
<body>
    <audio id="background-song" src="http://googleusercontent.com/file_content/5" loop></audio>
    <div id="gameContainer" class="game-container">
        <div id="gameCanvasContainer" class="hidden"></div>
        <div id="selectionScreen" class="screen">
            <h1 class="text-4xl font-bold">CHOOSE YOUR FIGHTER</h1>
            <p class="mt-2 text-gray-400">You have 3 chances to spin for a character.</p>
            <div id="spinner" class="spinner">?</div>
            <p class="text-lg">Chances Left: <span id="chancesLeft">3</span></p>
            <button id="spinButton" class="btn mt-4">Spin!</button>
        </div>
        <div id="trainingScreen" class="screen hidden">
            <h1 class="text-3xl font-bold">TRAINING...</h1>
            <p id="trainingMessage" class="mt-4 text-xl text-sky-300"></p>
            <p class="mt-2 text-gray-300">Master their techniques. Prepare for battle.</p>
        </div>
        <div id="messageOverlay" class="screen hidden">
             <h2 id="messageText" class="text-2xl font-bold"></h2>
        </div>
        <div id="combatUI" class="hidden p-4 md:p-8">
            <div id="worldSpaceUI"></div>
            <div class="flex justify-between items-start text-white">
                <div class="w-1/3">
                    <h3 id="playerName" class="text-xl font-bold text-shadow">Player</h3>
                    <div class="health-bar-container mt-1 max-w-xs">
                        <div id="playerHealthBar" class="health-bar player-health"></div>
                    </div>
                </div>
            </div>
            <div id="chargeBarContainer" class="absolute bottom-24 left-1/2 -translate-x-1/2 w-64 h-6 bg-gray-800 rounded-full border-2 border-sky-400 hidden pointer-events-auto">
                <div id="chargeBar" class="h-full bg-sky-400 rounded-full transition-all duration-100" style="width: 0%;"></div>
                <div class="absolute inset-0 text-white text-center font-bold text-sm leading-6">BREATHING CHARGE</div>
            </div>
            <div id="keyboard-instructions" class="absolute bottom-4 left-1/2 -translate-x-1/2 text-white bg-black bg-opacity-25 p-2 rounded-lg text-center text-sm md:text-base pointer-events-auto">
                <kbd class="px-2 py-1 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-300 rounded-lg">W,A,S,D</kbd>: Move | <kbd class="px-2 py-1 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-300 rounded-lg">Shift</kbd>: Dash | <kbd class="px-2 py-1 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-300 rounded-lg">Space</kbd>: Jump | <kbd class="px-2 py-1 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-300 rounded-lg">LMB/J</kbd>: Attack | <kbd class="px-2 py-1 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-300 rounded-lg">K</kbd>: Special | <kbd class="px-2 py-1 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-300 rounded-lg">Hold F</kbd>: Charge | <kbd class="px-2 py-1 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-300 rounded-lg">G</kbd>: Use Charge
            </div>
        </div>
        <div id="endScreen" class="screen hidden">
            <h1 id="endTitle" class="text-4xl font-bold"></h1>
            <p id="endMessage" class="mt-4 text-xl"></p>
            <button id="restartButton" class="btn mt-6">Play Again</button>
        </div>

        <div id="mobileControls" class="hidden">
            <div id="joystick-container">
                <div id="joystick-thumb"></div>
            </div>
            <div id="action-buttons" style="grid-template-areas: '. jump .' 'dash . attack' 'special charge use-charge';">
                <div id="btn-jump" class="action-btn" style="grid-area: jump;">Jump</div>
                <div id="btn-dash" class="action-btn" style="grid-area: dash;">Dash</div>
                <div id="btn-attack" class="action-btn" style="grid-area: attack; width: 80px; height: 80px;">Attack</div>
                <div id="btn-special" class="action-btn" style="grid-area: special;">Special</div>
                <div id="btn-charge" class="action-btn" style="grid-area: charge;">Charge</div>
                <div id="btn-use-charge" class="action-btn" style="grid-area: use-charge;">Use</div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM ELEMENTS ---
        const selectionScreen = document.getElementById('selectionScreen');
        const trainingScreen = document.getElementById('trainingScreen');
        const combatUI = document.getElementById('combatUI');
        const endScreen = document.getElementById('endScreen');
        const messageOverlay = document.getElementById('messageOverlay');
        const messageText = document.getElementById('messageText');
        const gameCanvasContainer = document.getElementById('gameCanvasContainer');
        const spinner = document.getElementById('spinner');
        const chancesLeftEl = document.getElementById('chancesLeft');
        const spinButton = document.getElementById('spinButton');
        const trainingMessage = document.getElementById('trainingMessage');
        const playerNameEl = document.getElementById('playerName');
        const playerHealthBar = document.getElementById('playerHealthBar');
        const chargeBarContainer = document.getElementById('chargeBarContainer');
        const chargeBar = document.getElementById('chargeBar');
        const endTitle = document.getElementById('endTitle');
        const endMessage = document.getElementById('endMessage');
        const restartButton = document.getElementById('restartButton');
        const worldSpaceUI = document.getElementById('worldSpaceUI');

        // --- GAME STATE & CONFIG ---
        let gameState = 'selection';
        let chances = 3;
        let gameStage = 1;
        let selectedCharacter = null;
        let animationFrameId;
        let clock = new THREE.Clock();
        let demons = [];

        const characters = [
            { name: 'Tanjiro', breathing: 'Sun Breathing', color: 0xf97316 },
            { name: 'Zenitsu', breathing: 'Thunder Breathing', color: 0xfacc15 },
            { name: 'Inosuke', breathing: 'Beast Breathing', color: 0x6b7280 },
            { name: 'Giyu', breathing: 'Water Breathing', color: 0x60a5fa },
            { name: 'Shinobu', breathing: 'Insect Breathing', color: 0xa855f7 },
            { name: 'Rengoku', breathing: 'Flame Breathing', color: 0xf97316 },
        ];
        
        const keys = { w: false, a: false, s: false, d: false, j: false, k: false, ' ': false, shift: false, f: false, g: false };
        const GRAVITY = 0.015;

        // --- 3D SCENE SETUP ---
        let scene, camera, renderer, playerModel, ground, defenseShield, specialAttackEffect, ultimateEffectGroup, ultimateDragon, victoryAura, playerAura;
        let cameraYaw = new THREE.Object3D();
        let cameraPitch = new THREE.Object3D();
        cameraYaw.add(cameraPitch);
        
        function createCharacterModel(color, isPlayer = false) {
            const group = new THREE.Group();
            const torsoMaterial = new THREE.MeshToonMaterial({ color: color });
            const headMaterial = new THREE.MeshToonMaterial({ color: 0xffdbac });
            const limbMaterial = new THREE.MeshToonMaterial({ color: 0x4a4a4a });
            const handMaterial = new THREE.MeshToonMaterial({ color: 0xffdbac });

            let torso, head, leftLeg, rightLeg, rightArm, leftArm;

            if (isPlayer) {
                const torsoGeometry = new THREE.CylinderGeometry(0.4, 0.5, 1.2, 8);
                torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                torso.castShadow = true;
                torso.position.y = 1.6;
                torso.name = "torso";
                group.add(torso);

                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                head = new THREE.Mesh(headGeometry, headMaterial);
                head.castShadow = true;
                head.position.y = 2.4;
                head.name = "head";
                group.add(head);

                const legGeometry = new THREE.CylinderGeometry(0.2, 0.15, 1.0, 8);
                leftLeg = new THREE.Mesh(legGeometry, limbMaterial);
                rightLeg = new THREE.Mesh(legGeometry, limbMaterial);
                leftLeg.position.set(-0.2, 0.5, 0);
                rightLeg.position.set(0.2, 0.5, 0);
                leftLeg.name = "leftLeg";
                rightLeg.name = "rightLeg";
                leftLeg.castShadow = true;
                rightLeg.castShadow = true;
                group.add(leftLeg, rightLeg);

                const upperArmGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.7, 8);
                const forearmGeo = new THREE.CylinderGeometry(0.12, 0.1, 0.6, 8);
                const handGeo = new THREE.SphereGeometry(0.12, 8, 8);

                rightArm = new THREE.Group();
                rightArm.name = "rightArm";
                const rightUpperArm = new THREE.Mesh(upperArmGeo, limbMaterial);
                rightUpperArm.position.y = -0.35;
                rightArm.add(rightUpperArm);

                const rightForearm = new THREE.Mesh(forearmGeo, limbMaterial);
                rightForearm.position.y = -0.65;
                rightUpperArm.add(rightForearm); 

                const rightHand = new THREE.Mesh(handGeo, handMaterial);
                rightHand.name = "rightHand";
                rightHand.position.y = -0.35;
                rightForearm.add(rightHand);

                rightArm.position.set(-0.5, 2.0, 0);
                group.add(rightArm);
                
                leftArm = new THREE.Group();
                leftArm.name = "leftArm";
                const leftUpperArm = new THREE.Mesh(upperArmGeo, limbMaterial);
                leftUpperArm.position.y = -0.35;
                leftArm.add(leftUpperArm);

                const leftForearm = new THREE.Mesh(forearmGeo, limbMaterial);
                leftForearm.position.y = -0.65;
                leftUpperArm.add(leftForearm);

                const leftHand = new THREE.Mesh(handGeo, handMaterial);
                leftHand.name = "leftHand";
                leftHand.position.y = -0.35;
                leftForearm.add(leftHand);

                leftArm.position.set(0.5, 2.0, 0);
                group.add(leftArm);

                const swordGroup = new THREE.Group();
                swordGroup.name = "sword";
                const hiltMaterial = new THREE.MeshToonMaterial({ color: 0x333333 });
                const bladeMaterial = new THREE.MeshToonMaterial({ color: 0xCCCCCC, emissive: 0x000000 });
                
                const hiltGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
                const hilt = new THREE.Mesh(hiltGeometry, hiltMaterial);
                swordGroup.add(hilt);
                
                const bladeGeometry = new THREE.BoxGeometry(0.05, 1.8, 0.2);
                const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                blade.name = "swordBlade";
                blade.position.y = 1.15;
                swordGroup.add(blade);
                
                swordGroup.position.set(0, 0.1, 0.1); 
                swordGroup.rotation.x = Math.PI / 2;
                swordGroup.rotation.y = Math.PI / 4;

                rightHand.add(swordGroup);

                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                context.fillStyle = '#000000';
                context.fillRect(0, 0, 64, 64);
                context.fillStyle = '#006400';
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        if ((i + j) % 2 === 0) {
                            context.fillRect(i * 16, j * 16, 16, 16);
                        }
                    }
                }
                const haoriTexture = new THREE.CanvasTexture(canvas);
                haoriTexture.wrapS = THREE.RepeatWrapping;
                haoriTexture.wrapT = THREE.RepeatWrapping;
                haoriTexture.repeat.set(4, 4);

                const haoriMaterial = new THREE.MeshToonMaterial({
                    map: haoriTexture,
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide
                });
                const haoriGeometry = new THREE.PlaneGeometry(1.5, 1.2);
                const haori = new THREE.Mesh(haoriGeometry, haoriMaterial);
                haori.name = "haori";
                haori.position.y = 0;
                haori.position.z = -0.26;
                torso.add(haori);

                const hairMaterial = new THREE.MeshToonMaterial({ color: 0x8B4513 });
                const ponytailGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
                const ponytail = new THREE.Mesh(ponytailGeometry, hairMaterial);
                ponytail.name = "ponytail";
                ponytail.position.y = -0.6;
                ponytail.position.z = -0.4;
                ponytail.rotation.x = -Math.PI / 8;
                ponytail.visible = false;
                head.add(ponytail);

                const scarMaterial = new THREE.MeshBasicMaterial({ color: 0x800000, transparent: true, opacity: 0, side: THREE.DoubleSide });
                const scarGeometry = new THREE.PlaneGeometry(0.2, 0.2);
                const scar = new THREE.Mesh(scarGeometry, scarMaterial);
                scar.name = "scar";
                scar.position.set(-0.2, 0.2, 0.41);
                scar.rotation.y = Math.PI / 8;
                head.add(scar);

            } else {
                const torsoGeometry = new THREE.CylinderGeometry(0.5, 0.6, 1.4, 8);
                torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
                torso.castShadow = true;
                torso.position.y = 1.6;
                torso.name = "torso";
                group.add(torso);

                const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                head = new THREE.Mesh(headGeometry, headMaterial);
                head.castShadow = true;
                head.position.y = 2.6;
                head.name = "head";
                group.add(head);

                const legGeometry = new THREE.CylinderGeometry(0.25, 0.2, 1.2, 8);
                leftLeg = new THREE.Mesh(legGeometry, limbMaterial);
                rightLeg = new THREE.Mesh(legGeometry, limbMaterial);
                leftLeg.position.set(-0.3, 0.6, 0);
                rightLeg.position.set(0.3, 0.6, 0);
                leftLeg.name = "leftLeg";
                rightLeg.name = "rightLeg";
                leftLeg.castShadow = true;
                rightLeg.castShadow = true;
                group.add(leftLeg, rightLeg);

                const upperArmGeo = new THREE.CylinderGeometry(0.2, 0.18, 0.8, 8);
                const forearmGeo = new THREE.CylinderGeometry(0.18, 0.15, 0.7, 8);
                const handGeo = new THREE.SphereGeometry(0.18, 8, 8);

                rightArm = new THREE.Group();
                rightArm.name = "rightArm";
                const rightUpperArm = new THREE.Mesh(upperArmGeo, limbMaterial);
                rightUpperArm.position.y = -0.4;
                rightArm.add(rightUpperArm);

                const rightForearm = new THREE.Mesh(forearmGeo, limbMaterial);
                rightForearm.position.y = -0.75;
                rightUpperArm.add(rightForearm); 

                const rightHand = new THREE.Mesh(handGeo, handMaterial);
                rightHand.name = "rightHand";
                rightHand.position.y = -0.4;
                rightForearm.add(rightHand);

                rightArm.position.set(-0.6, 2.1, 0);
                group.add(rightArm);
                
                leftArm = new THREE.Group();
                leftArm.name = "leftArm";
                const leftUpperArm = new THREE.Mesh(upperArmGeo, limbMaterial);
                leftUpperArm.position.y = -0.4;
                leftArm.add(leftUpperArm);

                const leftForearm = new THREE.Mesh(forearmGeo, limbMaterial);
                leftForearm.position.y = -0.75;
                leftUpperArm.add(leftForearm);

                const leftHand = new THREE.Mesh(handGeo, handMaterial);
                leftHand.name = "leftHand";
                leftHand.position.y = -0.4;
                leftForearm.add(leftHand);

                leftArm.position.set(0.6, 2.1, 0);
                group.add(leftArm);

                const spikeGeo = new THREE.ConeGeometry(0.1, 0.3, 4);
                const spikeMat = new THREE.MeshToonMaterial({ color: 0x555555 });
                for (let i = 0; i < 5; i++) {
                    const spike = new THREE.Mesh(spikeGeo, spikeMat);
                    spike.position.set((Math.random() - 0.5) * 1, 1.8 + (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 1);
                    spike.rotation.x = Math.random() * Math.PI;
                    spike.rotation.z = Math.random() * Math.PI;
                    group.add(spike);
                }
            }

            group.scale.set(0.8, 0.8, 0.8);
            return group;
        }

        function createTree() {
            const tree = new THREE.Group();
            const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
            const trunkMat = new THREE.MeshToonMaterial({ color: 0x8b5e34 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1.5;
            tree.add(trunk);
            const leavesGeo = new THREE.SphereGeometry(2, 8, 6);
            const leavesMat = new THREE.MeshToonMaterial({ color: 0x22c55e });
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 4;
            tree.add(leaves);
            tree.castShadow = true;
            return tree;
        }
        
        function createDragon(color) {
            const dragonGroup = new THREE.Group();
            const segments = 20;
            const headSize = 0.6;
            const bodySize = 0.4;
            const material = new THREE.MeshToonMaterial({ color: color, transparent: true, opacity: 0.8 });
            const headGroup = new THREE.Group();
            const headBase = new THREE.Mesh(new THREE.SphereGeometry(headSize, 8, 6), material);
            headGroup.add(headBase);
            const snout = new THREE.Mesh(new THREE.ConeGeometry(headSize*0.6, headSize*1.5, 8), material);
            snout.position.z = headSize * 0.8;
            snout.rotation.x = Math.PI / 2;
            headGroup.add(snout);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(headSize*0.2, 8, 6), eyeMat);
            const rightEye = leftEye.clone();
            leftEye.position.set(headSize*0.5, headSize*0.3, headSize*0.4);
            rightEye.position.set(-headSize*0.5, headSize*0.3, headSize*0.4);
            headGroup.add(leftEye, rightEye);
            dragonGroup.add(headGroup);
            for (let i = 1; i < segments; i++) {
                const size = headSize - (i / segments) * (headSize - bodySize);
                dragonGroup.add(new THREE.Mesh(new THREE.SphereGeometry(size, 8, 6), material));
            }
            dragonGroup.visible = false;
            dragonGroup.userData.path = Array(segments).fill().map(() => new THREE.Vector3());
            return dragonGroup;
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.add(cameraYaw);
            scene.background = new THREE.Color(0x87ceeb); 
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            cameraPitch.add(camera);
            camera.position.set(0, 1.5, 7);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            gameCanvasContainer.appendChild(renderer.domElement);
            renderer.domElement.id = 'gameCanvas';

            scene.add(new THREE.HemisphereLight(0xffffbb, 0x080820, 1));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.set(1024, 1024);
            scene.add(directionalLight);

            ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshToonMaterial({ color: 0x22c55e }));
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            for(let i=0; i<15; i++) {
                const tree = createTree();
                tree.position.set((Math.random()-0.5)*150, 0, (Math.random()-0.5)*150);
                scene.add(tree);
            }

            playerModel = createCharacterModel(0xffffff, true);
            scene.add(playerModel);
            
            defenseShield = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 32), new THREE.MeshBasicMaterial({ color: 0xade8f4, transparent: true, opacity: 0.4 }));
            defenseShield.visible = false;
            scene.add(defenseShield);
            
            specialAttackEffect = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 16), new THREE.MeshToonMaterial({ transparent: true, opacity: 0.8 }));
            specialAttackEffect.visible = false;
            scene.add(specialAttackEffect);

            ultimateEffectGroup = new THREE.Group();
            scene.add(ultimateEffectGroup);
            
            ultimateDragon = createDragon(0xffffff);
            scene.add(ultimateDragon);
            
            playerAura = new THREE.Group();
            playerModel.add(playerAura);

            victoryAura = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 16), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending }));
            victoryAura.visible = false;
            scene.add(victoryAura);
        }

        const player = { speed: 0.15, health: 100, maxHealth: 100, isAttacking: false, attackCooldown: 0, isDefending: false, defenseCooldown: 0, attackFrame: 0, attackStage: 0, attackComboTimeout: 0, velocityY: 0, isSpecialAttacking: false, specialAttackCooldown: 0, specialAttackFrame: 0, walkAnimationTime: 0, isDashing: false, dashCooldown: 0, dashFrame: 0, dashDirection: new THREE.Vector3(), isCharging: false, chargeLevel: 0, isUltimateAttacking: false, ultimateAttackFrame: 0, ultimateStartPos: new THREE.Vector3(), ultimatePath: [], ultimatePathIndex: 0, auraActive: false, auraTimer: 0, isVictoryAura: false, victoryAuraFrame: 0 };
        
        function switchScreen(screenName) {
            [selectionScreen, trainingScreen, combatUI, endScreen, messageOverlay, gameCanvasContainer, chargeBarContainer].forEach(el => el.classList.add('hidden'));
            if (screenName === 'combat') {
                combatUI.classList.remove('hidden');
                gameCanvasContainer.classList.remove('hidden');
                chargeBarContainer.classList.remove('hidden');
                if (renderer && !isTouchDevice) renderer.domElement.requestPointerLock();
            } else {
                if (document.pointerLockElement) document.exitPointerLock();
                document.getElementById(screenName + 'Screen')?.classList.remove('hidden');
            }
        }

        function handleSpin() {
            if (chances <= 0) return;
            chances--;
            chancesLeftEl.textContent = chances;
            spinButton.disabled = true;
            let spinCount = 0;
            const spinInterval = setInterval(() => {
                spinCount++;
                const randomChar = characters[Math.floor(Math.random() * characters.length)];
                spinner.textContent = randomChar.name;
                spinner.style.color = `#${randomChar.color.toString(16).padStart(6, '0')}`;
                if (spinCount > 20) {
                    clearInterval(spinInterval);
                    selectedCharacter = randomChar;
                    spinner.textContent = selectedCharacter.name;
                    finalizeSelection();
                }
            }, 100);
        }

        function finalizeSelection() { setTimeout(() => { gameState = 'training'; trainingMessage.textContent = `${selectedCharacter.name}, you will learn ${selectedCharacter.breathing}.`; switchScreen('training'); startTraining(); }, 1500); }
        function startTraining() { setTimeout(() => { initCombat(); switchScreen('combat'); }, 4000); }

        function spawnWave(stage) {
            worldSpaceUI.innerHTML = '';
            demons = [];
            
            const numDemons = 2 + stage;
            
            for (let i = 0; i < numDemons; i++) {
                const newDemonModel = createCharacterModel(0xdc2626, false);
                const scale = 1.0 + (stage - 1) * 0.1 + (Math.random() - 0.5) * 0.1;
                newDemonModel.scale.set(scale, scale, scale);
                
                const angle = (i / numDemons) * Math.PI * 2;
                const radius = 15 + Math.random() * 5;
                const spawnPos = new THREE.Vector3(
                    playerModel.position.x + Math.sin(angle) * radius,
                    0,
                    playerModel.position.z + Math.cos(angle) * radius
                );
                newDemonModel.position.copy(spawnPos);

                const healthBarContainer = document.createElement('div');
                healthBarContainer.className = 'demon-health-bar-world-container';
                const healthBarFill = document.createElement('div');
                healthBarFill.className = 'demon-health-bar-world-fill';
                healthBarContainer.appendChild(healthBarFill);
                worldSpaceUI.appendChild(healthBarContainer);

                const newDemon = {
                    model: newDemonModel,
                    speed: 0.04 + (stage - 1) * 0.005 + Math.random() * 0.01,
                    health: 80 + (stage - 1) * 40,
                    maxHealth: 80 + (stage - 1) * 40,
                    attackCooldown: 120 + Math.floor(Math.random() * 60),
                    regenRate: stage > 1 ? 0.01 * stage : 0,
                    walkAnimationTime: Math.random() * 10,
                    hitCooldown: 0,
                    deathFrame: 0,
                    state: 'alive',
                    healthBar: { container: healthBarContainer, fill: healthBarFill }
                };
                
                newDemonModel.getObjectByName('torso').material.color.set(new THREE.Color().setHSL(0, 0.8, 0.5 - stage * 0.05));

                demons.push(newDemon);
                scene.add(newDemonModel);
            }
            gameState = 'combat';
        }

        function initCombat() {
            gameStage = 1;
            player.health = 100;
            playerModel.position.set(-5, 0, 0);
            playerModel.getObjectByName('torso').material.color.set(selectedCharacter.color);
            playerNameEl.textContent = selectedCharacter.name;
            spawnWave(gameStage);
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            animate();
        }

        function triggerDemonDeath(demon) {
            demon.state = 'dying';
            demon.deathFrame = 0;
            demon.shards = [];

            const meshesToMove = [];
            demon.model.traverse(child => {
                if (child.isMesh) {
                    meshesToMove.push(child);
                }
            });

            meshesToMove.forEach(child => {
                scene.attach(child);
                child.material = child.material.clone();
                child.material.transparent = true;

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * 0.3 + 0.1,
                    (Math.random() - 0.5) * 0.2
                );
                const rotation = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                );

                demon.shards.push({ mesh: child, velocity: velocity, rotation: rotation });
            });
            
            const modelPos = demon.model.position.clone();
            scene.remove(demon.model);

            demon.fireParticles = new THREE.Group();
            demon.fireParticles.position.copy(modelPos);
            scene.add(demon.fireParticles);
            
            const particleGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const particleColors = [0xffa500, 0xff4500, 0xffd700];

            for (let i = 0; i < 50; i++) {
                const color = particleColors[Math.floor(Math.random() * particleColors.length)];
                const particleMat = new THREE.MeshBasicMaterial({ 
                    color: color, 
                    blending: THREE.AdditiveBlending, 
                    transparent: true 
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.15,
                    Math.random() * 0.15,
                    (Math.random() - 0.5) * 0.15
                );
                particle.userData.lifetime = Math.random() * 60 + 30;
                particle.userData.initialLifetime = particle.userData.lifetime;

                demon.fireParticles.add(particle);
            }
        }

        function update() {
            const delta = clock.getDelta();
            
            if (player.attackCooldown > 0) player.attackCooldown--;
            if (player.specialAttackCooldown > 0) player.specialAttackCooldown--;
            if (player.dashCooldown > 0) player.dashCooldown--;
            if (player.attackComboTimeout > 0) player.attackComboTimeout--; else player.attackStage = 0;
            if (player.defenseCooldown > 0) player.defenseCooldown--; else player.isDefending = false;
            defenseShield.visible = player.isDefending;
            if(player.isDefending) defenseShield.position.copy(playerModel.position);
            
            const moveDirection = new THREE.Vector3();
            const canMove = !player.isDashing && !player.isCharging && !player.isUltimateAttacking;
            if (canMove) {
                if (keys.w) moveDirection.z = -1;
                if (keys.s) moveDirection.z = 1;
                if (keys.a) moveDirection.x = -1;
                if (keys.d) moveDirection.x = 1;
            }
            const isPlayerMoving = moveDirection.lengthSq() > 0;
            
            moveDirection.normalize().applyQuaternion(cameraYaw.quaternion);
            playerModel.position.add(moveDirection.multiplyScalar(player.speed));
            
            player.velocityY -= GRAVITY;
            playerModel.position.y += player.velocityY;

            if (playerModel.position.y < 0) {
                playerModel.position.y = 0;
                player.velocityY = 0;
            }
            
            const cameraPivotPosition = playerModel.position.clone().add(new THREE.Vector3(0, 2.0, 0));
            cameraYaw.position.copy(cameraPivotPosition);
            playerModel.rotation.y = cameraYaw.rotation.y + Math.PI;

            demons.forEach(demon => {
                if (demon.state === 'dying') {
                    demon.deathFrame++;
                    const deathDuration = 180;

                    demon.shards.forEach(shard => {
                        shard.velocity.y -= GRAVITY * 0.5;
                        shard.mesh.position.add(shard.velocity);
                        shard.mesh.rotation.x += shard.rotation.x;
                        shard.mesh.rotation.y += shard.rotation.y;
                        shard.mesh.rotation.z += shard.rotation.z;
                        shard.mesh.material.opacity = 1.0 - (demon.deathFrame / deathDuration);
                    });

                    demon.fireParticles.children.forEach(particle => {
                        particle.position.add(particle.userData.velocity);
                        particle.userData.lifetime--;
                        particle.material.opacity = particle.userData.lifetime / particle.userData.initialLifetime;
                    });
                    
                    if (demon.deathFrame > deathDuration) {
                        demon.shards.forEach(shard => scene.remove(shard.mesh));
                        scene.remove(demon.fireParticles);
                        demon.state = 'dead';
                        if (demon.healthBar) demon.healthBar.container.remove();
                    }
                    return;
                }
                
                if (demon.state !== 'alive') return;

                if (demon.hitCooldown > 0) demon.hitCooldown--;
                if (demon.hitCooldown === 0) demon.model.getObjectByName('torso').material.color.set(new THREE.Color().setHSL(0, 0.8, 0.5 - gameStage * 0.05));

                if(demon.health < demon.maxHealth) demon.health += demon.regenRate;

                const targetPos = playerModel.position.clone();
                targetPos.y = demon.model.position.y;
                demon.model.lookAt(targetPos);

                const distance = playerModel.position.distanceTo(demon.model.position);
                let isDemonMoving = false;
                if (distance > 2.5) {
                    isDemonMoving = true;
                    const direction = new THREE.Vector3().subVectors(playerModel.position, demon.model.position).normalize();
                    demon.model.position.add(direction.multiplyScalar(demon.speed));
                } else if (demon.attackCooldown <= 0) {
                    demon.attackCooldown = 150 - gameStage * 5;
                    setTimeout(() => {
                        if (demon.state === 'alive' && !player.isDefending && player.health > 0) {
                            player.health = Math.max(0, player.health - (10 + gameStage * 2));
                        }
                    }, 300);
                }
                if(demon.attackCooldown > 0) demon.attackCooldown--;

                const demonLeftLeg = demon.model.getObjectByName('leftLeg');
                const demonRightLeg = demon.model.getObjectByName('rightLeg');
                if (isDemonMoving) {
                    demon.walkAnimationTime += delta * 8;
                    demonLeftLeg.rotation.x = Math.sin(demon.walkAnimationTime) * 0.5;
                    demonRightLeg.rotation.x = -Math.sin(demon.walkAnimationTime) * 0.5;
                } else {
                    demonLeftLeg.rotation.x = 0;
                    demonRightLeg.rotation.x = 0;
                }
            });

            const leftLeg = playerModel.getObjectByName('leftLeg');
            const rightLeg = playerModel.getObjectByName('rightLeg');
            if (isPlayerMoving && playerModel.position.y === 0) {
                player.walkAnimationTime += delta * 10;
                leftLeg.rotation.x = Math.sin(player.walkAnimationTime) * 0.5;
                rightLeg.rotation.x = -Math.sin(player.walkAnimationTime) * 0.5;
            } else {
                leftLeg.rotation.x = 0;
                rightLeg.rotation.x = 0;
            }

            const rightArm = playerModel.getObjectByName("rightArm");
            const leftArm = playerModel.getObjectByName("leftArm");
            if (rightArm && leftArm && !player.isAttacking) {
                rightArm.rotation.set(0, 0, 0.2);
                leftArm.rotation.set(0, 0, -0.2);
            }

            if (player.isDashing) {
                player.dashFrame++;
                playerModel.position.add(player.dashDirection.clone().multiplyScalar(0.8));
                if (player.dashFrame >= 15) player.isDashing = false;
            }

            if (player.isAttacking) {
                player.attackFrame++;
                const animationDuration = 20;
                const progress = player.attackFrame / animationDuration;
                if (rightArm) {
                    switch (player.attackStage) {
                        case 1: rightArm.rotation.z=0.2+Math.sin(progress*Math.PI)*2.5; rightArm.rotation.x=Math.sin(progress*Math.PI)*0.5; break;
                        case 2: rightArm.rotation.y=Math.sin(progress * Math.PI)*2.5; break;
                        default: rightArm.rotation.z=0.2-Math.sin(progress*Math.PI)*2.0; break;
                    }
                }
                if (player.attackFrame > 5 && player.attackFrame < 18) {
                    demons.forEach(demon => {
                       if (demon.state === 'alive') {
                            const dist = playerModel.position.distanceTo(demon.model.position);
                            const pDir = new THREE.Vector3(); playerModel.getWorldDirection(pDir);
                            const dDir = new THREE.Vector3().subVectors(demon.model.position, playerModel.position).normalize();
                            if (dist < 4.5 && pDir.angleTo(dDir) < Math.PI / 1.5) {
                                demon.health -= 2.5; 
                                demon.hitCooldown = 10;
                                demon.model.getObjectByName('torso').material.color.set(0xffffff);
                            }
                        }
                    });
                }
                if (player.attackFrame >= animationDuration) player.isAttacking = false;
            }

            if (player.isSpecialAttacking) {
                player.specialAttackFrame++;
                const duration = 60;
                const progress = player.specialAttackFrame / duration;
                specialAttackEffect.visible = true;
                specialAttackEffect.position.copy(playerModel.position);
                const scale = progress * 20;
                specialAttackEffect.scale.set(scale, scale, scale);
                specialAttackEffect.material.opacity = 1.0 - progress;
                if (player.specialAttackFrame === 1) {
                    demons.forEach(demon => {
                        if (playerModel.position.distanceTo(demon.model.position) < 20 && demon.state === 'alive') {
                            demon.health -= (50 * gameStage);
                            demon.hitCooldown = 30;
                            demon.model.getObjectByName('torso').material.color.set(0xffffff);
                        }
                    });
                }
                if (player.specialAttackFrame >= duration) {
                    player.isSpecialAttacking = false;
                    specialAttackEffect.visible = false;
                }
            }
            
            player.isCharging = keys.f && !isPlayerMoving;
            if (player.isCharging && player.chargeLevel < 100) {
                player.chargeLevel += 0.8; 
            } else if (!player.isCharging && player.chargeLevel > 0) {
                player.chargeLevel -= 1.5; 
            }
            player.chargeLevel = Math.max(0, Math.min(100, player.chargeLevel));
            chargeBar.style.width = `${player.chargeLevel}%`;
            chargeBar.classList.toggle('full', player.chargeLevel >= 100);

            const swordBlade = playerModel.getObjectByName("swordBlade");
            if (swordBlade) {
                const chargeRatio = player.chargeLevel / 100;
                const originalColor = new THREE.Color(0xCCCCCC);
                const chargeColor = new THREE.Color(0xff0000);
                swordBlade.material.color.copy(originalColor).lerp(chargeColor, chargeRatio);
                
                const originalEmissive = new THREE.Color(0x000000);
                const chargeEmissive = new THREE.Color(0x880000);
                swordBlade.material.emissive.copy(originalEmissive).lerp(chargeEmissive, chargeRatio);

                const torso = playerModel.getObjectByName("torso");
                const haori = playerModel.getObjectByName("haori");
                const ponytail = playerModel.getObjectByName("ponytail");
                const head = playerModel.getObjectByName("head");
                const scar = playerModel.getObjectByName("scar");

                if (torso && haori && ponytail && head && scar) {
                    const originalTorsoColor = new THREE.Color(selectedCharacter.color);
                    const newTorsoColor = new THREE.Color(0x333333);
                    torso.material.color.copy(originalTorsoColor).lerp(newTorsoColor, chargeRatio);
                    
                    const originalHeadColor = new THREE.Color(0xffdbac);
                    const newHeadColor = new THREE.Color(0x8B4513);
                    head.material.color.copy(originalHeadColor).lerp(newHeadColor, chargeRatio);

                    haori.material.opacity = chargeRatio;
                    scar.material.opacity = chargeRatio;
                    ponytail.visible = chargeRatio > 0.5;
                    ponytail.scale.y = (chargeRatio - 0.5) * 2;
                }
            }

            if (player.isCharging) {
                const chargeRatio = player.chargeLevel / 100;
                if (Math.random() < chargeRatio * 0.5) {
                    const particleGeo = new THREE.ConeGeometry(0.05, 0.5, 4);
                    const particleMat = new THREE.MeshBasicMaterial({
                        color: selectedCharacter.color,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        opacity: 0.8
                    });
                    const particle = new THREE.Mesh(particleGeo, particleMat);
                    const radius = 0.5;
                    particle.position.set(
                        (Math.random() - 0.5) * radius,
                        Math.random() * 1.5,
                        (Math.random() - 0.5) * radius
                    );
                    particle.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        0.05 + Math.random() * 0.05,
                        (Math.random() - 0.5) * 0.02
                    );
                    particle.userData.lifetime = 30 + Math.random() * 30;
                    playerAura.add(particle);
                }
            }

            playerAura.children.forEach(particle => {
                particle.position.add(particle.userData.velocity);
                particle.userData.lifetime--;
                particle.material.opacity = (particle.userData.lifetime / 60);
                if (particle.userData.lifetime <= 0) {
                    playerAura.remove(particle);
                }
            });

            if (player.isUltimateAttacking) {
                player.ultimateAttackFrame++;
                const chargeDuration = 90;

                if (player.ultimateAttackFrame <= chargeDuration) {
                    const breathing = selectedCharacter.breathing;
                    if (breathing === 'Sun Breathing' || breathing === 'Flame Breathing' || breathing === 'Water Breathing') {
                        ultimateDragon.visible = true;
                        const angle = (player.ultimateAttackFrame / chargeDuration) * Math.PI * 4;
                        const radius = 5;
                        const head = ultimateDragon.children[0];
                        head.position.set(
                            player.ultimateStartPos.x + Math.cos(angle) * radius,
                            player.ultimateStartPos.y + 1 + Math.sin(angle * 2) * 1.5,
                            player.ultimateStartPos.z + Math.sin(angle) * radius
                        );
                        head.lookAt(player.ultimateStartPos);
                        ultimateDragon.userData.path.pop();
                        ultimateDragon.userData.path.unshift(head.position.clone());
                        for (let i = 1; i < ultimateDragon.children.length; i++) {
                            ultimateDragon.children[i].position.copy(ultimateDragon.userData.path[i]);
                        }
                    } else {
                        ultimateEffectGroup.visible = true;
                        ultimateEffectGroup.position.copy(player.ultimateStartPos);
                        ultimateEffectGroup.rotation.y += 0.2;
                    }
                }
                else {
                    ultimateDragon.visible = false;
                    ultimateEffectGroup.visible = false;

                    const dashPerDemonDuration = 15;

                    if (player.ultimatePath && player.ultimatePathIndex < player.ultimatePath.length) {
                        const currentTargetDemon = player.ultimatePath[player.ultimatePathIndex];
                        
                        if (currentTargetDemon.state !== 'alive') {
                            player.ultimatePathIndex++;
                        } else {
                             const startPos = (player.ultimatePathIndex === 0) 
                                ? player.ultimateStartPos.clone() 
                                : player.ultimatePath[player.ultimatePathIndex - 1].model.position.clone();
                            
                            const endPos = currentTargetDemon.model.position;
                            
                            const framesIntoCurrentDash = (player.ultimateAttackFrame - chargeDuration) - (player.ultimatePathIndex * dashPerDemonDuration);
                            const progress = Math.min(1.0, framesIntoCurrentDash / dashPerDemonDuration);

                            playerModel.position.lerpVectors(startPos, endPos, progress);

                            if (progress >= 1.0) {
                                currentTargetDemon.health = 0;
                                player.ultimatePathIndex++;
                            }
                        }
                    } else {
                        player.isUltimateAttacking = false;
                    }
                }
            }

            updateHealthBars();
            checkEndConditions();
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            if(renderer) {
                update();
                renderer.render(scene, camera);
            }
        }
        
        function updateHealthBars() {
            playerHealthBar.style.width = `${(player.health / player.maxHealth) * 100}%`;
            demons.forEach(demon => {
                if (demon.state !== 'dead' && demon.healthBar) {
                    const bar = demon.healthBar.container;
                    const pos = new THREE.Vector3();
                    const healthBarPosition = demon.model ? demon.model.position.clone() : new THREE.Vector3();
                    healthBarPosition.y += 2.8;
                    pos.copy(healthBarPosition);
                    pos.project(camera);

                    if (pos.z > 1) { 
                        bar.style.display = 'none'; 
                    } else {
                        bar.style.display = 'block';
                        const x = (pos.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
                        const y = (pos.y * -0.5 + 0.5) * renderer.domElement.clientHeight;
                        bar.style.left = `${x}px`;
                        bar.style.top = `${y}px`;
                        const healthPercent = (demon.health / demon.maxHealth) * 100;
                        demon.healthBar.fill.style.width = `${Math.max(0, healthPercent)}%`;
                    }
                }
            });
        }

        function checkEndConditions() {
            if (gameState === 'gameOver' || gameState === 'spawning') return;
            if (player.health <= 0) {
                gameState = 'gameOver';
                endTitle.textContent = 'You Have Been Defeated';
                endMessage.textContent = `You survived ${gameStage} wave(s). Train harder and try again.`;
                switchScreen('end');
                return;
            }
            demons.forEach(demon => {
                if (demon.health <= 0 && demon.state === 'alive') {
                    triggerDemonDeath(demon);
                }
            });
            if (demons.length > 0 && demons.every(d => d.state !== 'alive') && gameState === 'combat') {
               if (demons.every(d => d.state === 'dead')) {
                    gameState = 'spawning';
                    messageOverlay.classList.remove('hidden');
                    messageText.textContent = `Wave ${gameStage + 1} Starts!`;
                    player.health = Math.min(player.maxHealth, player.health + 25);
                    setTimeout(() => {
                        messageOverlay.classList.add('hidden');
                        spawnWave(++gameStage);
                    }, 2500);
               }
            }
        }
        
        function resetGame() { 
            gameState = 'selection'; 
            chances = 3; 
            gameStage = 1;
            selectedCharacter = null; 
            spinner.textContent = '?'; 
            chancesLeftEl.textContent = chances; 
            spinButton.disabled = false; 
            Object.keys(keys).forEach(k => keys[k] = false); 
            worldSpaceUI.innerHTML = '';
            demons.forEach(d => scene.remove(d.model));
            demons = [];
            switchScreen('selection'); 
        }

        spinButton.addEventListener('click', () => {
            if(!scene) {
                initThree();
                window.addEventListener('resize', onWindowResize, false);
            }
            const backgroundSong = document.getElementById('background-song');
            if (backgroundSong && backgroundSong.paused) {
                backgroundSong.play().catch(error => {
                    console.log("Audio playback failed. User interaction might be required.", error);
                });
            }
            handleSpin();
        });
        restartButton.addEventListener('click', resetGame);
        
        function triggerAttack() {
            if (gameState!=='combat'||player.attackCooldown>0||player.isAttacking||player.isDashing) return;
            player.isAttacking = true;
            player.attackFrame = 0;
            player.attackCooldown = 25;
            player.attackComboTimeout = 40;
            player.attackStage = (player.attackStage + 1) % 3;
        }

        function triggerJump() { if (!player.isDashing) player.velocityY = Math.min(player.velocityY + 0.3, 0.4); }

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = true;
            if (gameState !== 'combat') return;
            
            if (key === 'j') triggerAttack();
            if (key === ' ') triggerJump();

            if (key === 'k' && player.specialAttackCooldown <= 0 && player.health > 20 && !player.isDashing) {
                player.health -= 20;
                player.isSpecialAttacking = true;
                player.specialAttackFrame = 0;
                player.specialAttackCooldown = 300;
            }

            if (key === 'shift' && !player.isDashing && player.dashCooldown <= 0 && playerModel.position.y === 0) {
                player.isDashing = true;
                player.dashFrame = 0;
                player.dashCooldown = 120;
                const direction = new THREE.Vector3();
                playerModel.getWorldDirection(direction);
                player.dashDirection.copy(direction).multiplyScalar(-1);
                player.dashDirection.y = 0;
            }

            if (key === 'g' && player.chargeLevel >= 100 && !player.isUltimateAttacking) {
                player.isUltimateAttacking = true;
                player.ultimateAttackFrame = 0;
                player.ultimateStartPos.copy(playerModel.position);

                player.ultimatePath = demons
                    .filter(d => d.state === 'alive')
                    .sort((a, b) => playerModel.position.distanceTo(a.model.position) - playerModel.position.distanceTo(b.model.position));
                
                player.ultimatePathIndex = 0;
                player.chargeLevel = 0;
                
                while(ultimateEffectGroup.children.length > 0){ ultimateEffectGroup.remove(ultimateEffectGroup.children[0]); }
                const breathing = selectedCharacter.breathing;
                const color = selectedCharacter.color;
                switch(breathing) {
                    case 'Sun Breathing': case 'Flame Breathing': case 'Water Breathing':
                        ultimateDragon.children.forEach(c => c.traverse(sc => { if(sc.isMesh) sc.material.color.set(color); }));
                        break;
                    case 'Thunder Breathing':
                        for(let i=0; i<10; i++) {
                            const l = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,3,5), new THREE.MeshBasicMaterial({color:color}));
                            l.position.set((Math.random()-0.5)*6,(Math.random()-0.5)*6,(Math.random()-0.5)*6);
                            l.rotation.set(Math.random()*Math.PI,Math.random()*Math.PI,Math.random()*Math.PI);
                            ultimateEffectGroup.add(l);
                        }
                        break;
                    case 'Beast Breathing':
                        const s1=new THREE.Mesh(new THREE.BoxGeometry(4,0.1,0.1),new THREE.MeshBasicMaterial({color:color}));
                        const s2=s1.clone(); s1.rotation.y=0.7; s2.rotation.y=-0.7; ultimateEffectGroup.add(s1,s2);
                        break;
                    case 'Insect Breathing':
                        for(let i=0; i<50; i++) {
                            const b = new THREE.Mesh(new THREE.PlaneGeometry(0.3,0.3),new THREE.MeshBasicMaterial({color:color,side:THREE.DoubleSide,transparent:true,opacity:0.8}));
                            b.position.set((Math.random()-0.5)*4,(Math.random()-0.5)*4,(Math.random()-0.5)*4);
                            b.rotation.y=Math.random()*Math.PI*2; ultimateEffectGroup.add(b);
                        }
                        break;
                }
            }
        });

        window.addEventListener('keyup', (e) => { if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = false; });

        window.addEventListener('mousedown', (e) => {
            if (renderer && document.pointerLockElement !== renderer.domElement) { renderer.domElement.requestPointerLock(); return; }
            if (gameState !== 'combat') return;
            if (e.button === 0) triggerAttack();
            if (e.button === 2) {
                e.preventDefault();
                if (player.defenseCooldown <= 0 && !player.isAttacking && !player.isDashing) { 
                    player.isDefending = true; 
                    player.defenseCooldown = 180; 
                }
            }
        });
        
        window.addEventListener('mousemove', (e) => {
            if (renderer && document.pointerLockElement === renderer.domElement) {
                cameraYaw.rotation.y -= e.movementX * 0.002;
                cameraPitch.rotation.x -= e.movementY * 0.002;
                cameraPitch.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch.rotation.x));
            }
        });

        window.addEventListener('contextmenu', e => { if(gameState === 'combat') e.preventDefault(); });
        function onWindowResize() { if(camera) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); } }
        
        const isTouchDevice = 'ontouchstart' in window;
        if (isTouchDevice) {
            document.getElementById('mobileControls').classList.remove('hidden');
            document.getElementById('keyboard-instructions').classList.add('hidden');
            const joystick=document.getElementById('joystick-container'),thumb=document.getElementById('joystick-thumb');
            let j_active=false,j_center={x:0,y:0};
            joystick.addEventListener('touchstart',(e)=>{e.preventDefault();j_active=true;const r=joystick.getBoundingClientRect();j_center.x=r.left+r.width/2;j_center.y=r.top+r.height/2;},{passive:false});
            joystick.addEventListener('touchmove',(e)=>{if(!j_active)return;e.preventDefault();const t=e.touches[0];const dx=t.clientX-j_center.x,dy=t.clientY-j_center.y,dist=Math.sqrt(dx*dx+dy*dy),ang=Math.atan2(dy,dx),x=Math.min(30,dist)*Math.cos(ang),y=Math.min(30,dist)*Math.sin(ang);thumb.style.transform=`translate(${x}px,${y}px)`;keys.w=dy<-10;keys.s=dy>10;keys.a=dx<-10;keys.d=dx>10;},{passive:false});
            joystick.addEventListener('touchend',(e)=>{j_active=false;thumb.style.transform=`translate(0px,0px)`;keys.w=keys.a=keys.s=keys.d=false;});
            document.getElementById('btn-attack').addEventListener('touchstart',(e)=>{e.preventDefault();triggerAttack();});
            document.getElementById('btn-jump').addEventListener('touchstart',(e)=>{e.preventDefault();triggerJump();});
        }
        document.addEventListener('DOMContentLoaded', () => { switchScreen('selection'); });
    </script>
</body>
</html>
